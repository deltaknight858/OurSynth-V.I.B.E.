// Export Service for OurSynth-Eco noteflow
// Handles data export functionality for notes, notebooks, and mind maps

import { Note, Notebook, MindMap, ExportFormat, ServiceResponse, ItemId } from '../types/core';

interface ExportOptions {
  format: ExportFormat;
  includeMetadata?: boolean;
  includeAttachments?: boolean;
  dateFormat?: 'iso' | 'readable';
}

class ExportService {
  // Export a single note
  async exportNote(note: Note, options: ExportOptions): Promise<ServiceResponse<string | Blob>> {
    try {
      switch (options.format) {
        case 'markdown':
          return this.exportNoteAsMarkdown(note, options);
        case 'html':
          return this.exportNoteAsHtml(note, options);
        case 'json':
          return this.exportNoteAsJson(note, options);
        case 'pdf':
          return this.exportNoteAsPdf(note, options);
        default:
          return {
            success: false,
            error: `Unsupported export format: ${options.format}`
          };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export note'
      };
    }
  }

  // Export multiple notes
  async exportNotes(notes: Note[], options: ExportOptions): Promise<ServiceResponse<string | Blob>> {
    try {
      switch (options.format) {
        case 'markdown':
          return this.exportNotesAsMarkdown(notes, options);
        case 'html':
          return this.exportNotesAsHtml(notes, options);
        case 'json':
          return this.exportNotesAsJson(notes, options);
        case 'csv':
          return this.exportNotesAsCsv(notes, options);
        default:
          return {
            success: false,
            error: `Unsupported export format for multiple notes: ${options.format}`
          };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export notes'
      };
    }
  }

  // Export a notebook
  async exportNotebook(notebook: Notebook, options: ExportOptions): Promise<ServiceResponse<string | Blob>> {
    try {
      switch (options.format) {
        case 'markdown':
          return this.exportNotebookAsMarkdown(notebook, options);
        case 'html':
          return this.exportNotebookAsHtml(notebook, options);
        case 'json':
          return this.exportNotebookAsJson(notebook, options);
        default:
          return {
            success: false,
            error: `Unsupported export format for notebook: ${options.format}`
          };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export notebook'
      };
    }
  }

  // Export a mind map
  async exportMindMap(mindMap: MindMap, options: ExportOptions): Promise<ServiceResponse<string | Blob>> {
    try {
      switch (options.format) {
        case 'json':
          return this.exportMindMapAsJson(mindMap, options);
        case 'html':
          return this.exportMindMapAsHtml(mindMap, options);
        case 'csv':
          return this.exportMindMapAsCsv(mindMap, options);
        default:
          return {
            success: false,
            error: `Unsupported export format for mind map: ${options.format}`
          };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to export mind map'
      };
    }
  }

  // Private export methods for notes
  private async exportNoteAsMarkdown(note: Note, options: ExportOptions): Promise<ServiceResponse<string>> {
    let content = '';

    if (note.title) {
      content += `# ${note.title}\n\n`;
    }

    content += note.content;

    if (options.includeMetadata) {
      content += '\n\n---\n\n';
      content += `**Created:** ${this.formatDate(note.timestamp, options.dateFormat)}\n`;
      
      if (note.tags && note.tags.length > 0) {
        content += `**Tags:** ${note.tags.map(tag => `#${tag}`).join(', ')}\n`;
      }

      if (note.noteType) {
        content += `**Type:** ${note.noteType}\n`;
      }

      if (note.wizardMeta?.isWizardGenerated) {
        content += `**Source:** Generated by Pathways Wizard\n`;
        if (note.wizardMeta.projectType) {
          content += `**Project Type:** ${note.wizardMeta.projectType}\n`;
        }
      }
    }

    return {
      success: true,
      data: content,
      message: 'Note exported as Markdown'
    };
  }

  private async exportNoteAsHtml(note: Note, options: ExportOptions): Promise<ServiceResponse<string>> {
    let html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${note.title || 'Untitled Note'}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .metadata { border-top: 1px solid #eee; margin-top: 40px; padding-top: 20px; color: #666; font-size: 14px; }
        .tag { background: #f0f0f0; padding: 2px 6px; border-radius: 3px; margin-right: 4px; }
        pre { background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
`;

    if (note.title) {
      html += `    <h1>${this.escapeHtml(note.title)}</h1>\n`;
    }

    // Convert markdown-style content to basic HTML
    html += `    <div class="content">${this.markdownToHtml(note.content)}</div>\n`;

    if (options.includeMetadata) {
      html += `    <div class="metadata">\n`;
      html += `        <p><strong>Created:</strong> ${this.formatDate(note.timestamp, options.dateFormat)}</p>\n`;
      
      if (note.tags && note.tags.length > 0) {
        html += `        <p><strong>Tags:</strong> ${note.tags.map(tag => `<span class="tag">#${this.escapeHtml(tag)}</span>`).join('')}</p>\n`;
      }

      if (note.noteType) {
        html += `        <p><strong>Type:</strong> ${this.escapeHtml(note.noteType)}</p>\n`;
      }

      if (note.wizardMeta?.isWizardGenerated) {
        html += `        <p><strong>Source:</strong> Generated by Pathways Wizard</p>\n`;
      }

      html += `    </div>\n`;
    }

    html += `
</body>
</html>`;

    return {
      success: true,
      data: html,
      message: 'Note exported as HTML'
    };
  }

  private async exportNoteAsJson(note: Note, options: ExportOptions): Promise<ServiceResponse<string>> {
    const exportData = options.includeMetadata ? note : {
      id: note.id,
      content: note.content,
      title: note.title,
      tags: note.tags,
      timestamp: note.timestamp
    };

    return {
      success: true,
      data: JSON.stringify(exportData, null, 2),
      message: 'Note exported as JSON'
    };
  }

  private async exportNoteAsPdf(note: Note, options: ExportOptions): Promise<ServiceResponse<Blob>> {
    // This would require a PDF library like jsPDF or puppeteer
    // For now, return an error indicating this needs implementation
    return {
      success: false,
      error: 'PDF export not yet implemented - requires PDF generation library'
    };
  }

  // Export multiple notes
  private async exportNotesAsMarkdown(notes: Note[], options: ExportOptions): Promise<ServiceResponse<string>> {
    let content = '# Notes Export\n\n';
    
    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      const noteExport = await this.exportNoteAsMarkdown(note, { ...options, includeMetadata: false });
      
      if (noteExport.success && noteExport.data) {
        content += `## Note ${i + 1}\n\n`;
        content += noteExport.data;
        content += '\n\n---\n\n';
      }
    }

    if (options.includeMetadata) {
      content += `\n\n**Export Details:**\n`;
      content += `- Total Notes: ${notes.length}\n`;
      content += `- Export Date: ${this.formatDate(new Date(), options.dateFormat)}\n`;
    }

    return {
      success: true,
      data: content,
      message: `${notes.length} notes exported as Markdown`
    };
  }

  private async exportNotesAsHtml(notes: Note[], options: ExportOptions): Promise<ServiceResponse<string>> {
    let html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes Export</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .note { border-bottom: 2px solid #eee; margin-bottom: 40px; padding-bottom: 20px; }
        .note:last-child { border-bottom: none; }
        .metadata { color: #666; font-size: 14px; }
        .tag { background: #f0f0f0; padding: 2px 6px; border-radius: 3px; margin-right: 4px; }
    </style>
</head>
<body>
    <h1>Notes Export</h1>
`;

    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      html += `    <div class="note">\n`;
      html += `        <h2>Note ${i + 1}</h2>\n`;
      
      if (note.title) {
        html += `        <h3>${this.escapeHtml(note.title)}</h3>\n`;
      }
      
      html += `        <div>${this.markdownToHtml(note.content)}</div>\n`;
      
      if (options.includeMetadata) {
        html += `        <div class="metadata">\n`;
        html += `            <p>Created: ${this.formatDate(note.timestamp, options.dateFormat)}</p>\n`;
        if (note.tags && note.tags.length > 0) {
          html += `            <p>Tags: ${note.tags.map(tag => `<span class="tag">#${this.escapeHtml(tag)}</span>`).join('')}</p>\n`;
        }
        html += `        </div>\n`;
      }
      
      html += `    </div>\n`;
    }

    html += `
</body>
</html>`;

    return {
      success: true,
      data: html,
      message: `${notes.length} notes exported as HTML`
    };
  }

  private async exportNotesAsJson(notes: Note[], options: ExportOptions): Promise<ServiceResponse<string>> {
    const exportData = {
      exportDate: new Date().toISOString(),
      totalNotes: notes.length,
      notes: options.includeMetadata ? notes : notes.map(note => ({
        id: note.id,
        content: note.content,
        title: note.title,
        tags: note.tags,
        timestamp: note.timestamp
      }))
    };

    return {
      success: true,
      data: JSON.stringify(exportData, null, 2),
      message: `${notes.length} notes exported as JSON`
    };
  }

  private async exportNotesAsCsv(notes: Note[], options: ExportOptions): Promise<ServiceResponse<string>> {
    const headers = ['ID', 'Title', 'Content', 'Tags', 'Type', 'Created', 'Wizard Generated'];
    let csv = headers.join(',') + '\n';

    for (const note of notes) {
      const row = [
        note.id,
        note.title || '',
        `"${note.content.replace(/"/g, '""')}"`, // Escape quotes
        note.tags ? note.tags.join(';') : '',
        note.noteType || '',
        this.formatDate(note.timestamp, 'iso'),
        note.wizardMeta?.isWizardGenerated ? 'Yes' : 'No'
      ];
      csv += row.join(',') + '\n';
    }

    return {
      success: true,
      data: csv,
      message: `${notes.length} notes exported as CSV`
    };
  }

  // Notebook export methods
  private async exportNotebookAsMarkdown(notebook: Notebook, options: ExportOptions): Promise<ServiceResponse<string>> {
    let content = `# ${notebook.title}\n\n`;
    
    if (notebook.description) {
      content += `${notebook.description}\n\n`;
    }

    if (notebook.notes.length === 0) {
      content += '*This notebook contains no notes.*\n\n';
    } else {
      content += `## Notes (${notebook.notes.length})\n\n`;
      
      for (let i = 0; i < notebook.notes.length; i++) {
        const note = notebook.notes[i];
        content += `### ${note.title || `Note ${i + 1}`}\n\n`;
        content += `${note.content}\n\n`;
        
        if (note.tags && note.tags.length > 0) {
          content += `*Tags: ${note.tags.map(tag => `#${tag}`).join(', ')}*\n\n`;
        }
      }
    }

    if (options.includeMetadata) {
      content += '---\n\n';
      content += `**Notebook Details:**\n`;
      content += `- Created: ${this.formatDate(notebook.createdAt, options.dateFormat)}\n`;
      content += `- Updated: ${this.formatDate(notebook.updatedAt, options.dateFormat)}\n`;
      content += `- Total Notes: ${notebook.notes.length}\n`;
      
      if (notebook.tags && notebook.tags.length > 0) {
        content += `- Tags: ${notebook.tags.map(tag => `#${tag}`).join(', ')}\n`;
      }

      if (notebook.wizardMeta?.isWizardGenerated) {
        content += `- Source: Generated by Pathways Wizard\n`;
      }
    }

    return {
      success: true,
      data: content,
      message: 'Notebook exported as Markdown'
    };
  }

  private async exportNotebookAsHtml(notebook: Notebook, options: ExportOptions): Promise<ServiceResponse<string>> {
    // Similar implementation to note HTML export but for notebook structure
    // Implementation would be similar to exportNotebookAsMarkdown but with HTML formatting
    return {
      success: false,
      error: 'Notebook HTML export not yet implemented'
    };
  }

  private async exportNotebookAsJson(notebook: Notebook, options: ExportOptions): Promise<ServiceResponse<string>> {
    const exportData = options.includeMetadata ? notebook : {
      id: notebook.id,
      title: notebook.title,
      description: notebook.description,
      notes: notebook.notes,
      tags: notebook.tags
    };

    return {
      success: true,
      data: JSON.stringify(exportData, null, 2),
      message: 'Notebook exported as JSON'
    };
  }

  // Mind map export methods
  private async exportMindMapAsJson(mindMap: MindMap, options: ExportOptions): Promise<ServiceResponse<string>> {
    const exportData = options.includeMetadata ? mindMap : {
      id: mindMap.id,
      title: mindMap.title,
      description: mindMap.description,
      nodes: mindMap.nodes,
      edges: mindMap.edges
    };

    return {
      success: true,
      data: JSON.stringify(exportData, null, 2),
      message: 'Mind map exported as JSON'
    };
  }

  private async exportMindMapAsHtml(mindMap: MindMap, options: ExportOptions): Promise<ServiceResponse<string>> {
    return {
      success: false,
      error: 'Mind map HTML export not yet implemented'
    };
  }

  private async exportMindMapAsCsv(mindMap: MindMap, options: ExportOptions): Promise<ServiceResponse<string>> {
    const headers = ['Node ID', 'Title', 'Content', 'Tags', 'X', 'Y', 'Created'];
    let csv = headers.join(',') + '\n';

    for (const node of mindMap.nodes) {
      const row = [
        node.id,
        `"${node.title.replace(/"/g, '""')}"`,
        `"${(node.content || '').replace(/"/g, '""')}"`,
        node.tags ? node.tags.join(';') : '',
        node.x || 0,
        node.y || 0,
        this.formatDate(node.createdAt, 'iso')
      ];
      csv += row.join(',') + '\n';
    }

    return {
      success: true,
      data: csv,
      message: 'Mind map exported as CSV'
    };
  }

  // Utility methods
  private formatDate(date: Date, format?: 'iso' | 'readable'): string {
    if (format === 'readable') {
      return date.toLocaleString();
    }
    return date.toISOString();
  }

  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  private markdownToHtml(markdown: string): string {
    // Basic markdown to HTML conversion
    return markdown
      .replace(/^# (.+$)/gm, '<h1>$1</h1>')
      .replace(/^## (.+$)/gm, '<h2>$1</h2>')
      .replace(/^### (.+$)/gm, '<h3>$1</h3>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/^\s*(.+)$/gm, '<p>$1</p>')
      .replace(/<p><h/g, '<h')
      .replace(/<\/h[1-6]><\/p>/g, function(match) {
        return match.replace(/<\/p>$/, '');
      });
  }
}

// Export singleton instance
export const exportService = new ExportService();
export default exportService;